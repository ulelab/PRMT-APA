---
title: "hiererchical_clustering"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Add distal prox + find if gene lengthening or shortening

For each feature do dist vs proximal and then put feaure of gene as lengthening or shortening

```{r}
ds <- read_csv('../Outputs/All_categories_df.csv')
rownames(ds) <- ds$unique_featureID
```


```{r}
library(tidyr)

```

To add lengthening or shortening I need to decide on wich mean diff to use.
PRMT Reg cat: i used mean over timecourse
Reg: I looked at the siRNA picked the one with the biggest effect
Control: just control

I find which of the 3 siRNA causes the biggest effect and store that (instead of the mean)

```{r}
ds$RowMEAN <- 0
for (gene in unique(ds[ds$category=='Regulatable_sites',]$gene_ID)) {
   list <- as.vector(abs(ds[ds$gene_ID==gene,7:9]))
   l1 <- max(list[[1]],na.rm = T)
   l2 <- max(list[[2]],na.rm = T)
   l3 <- max(list[[3]],na.rm = T)
   ifelse((l1>l2 & l1>l3),
          ds[ds$gene_ID==gene,]$RowMEAN <- ds[ds$gene_ID==gene,]$mean_diffsiELAVL1,
          ifelse((l2>l1 & l2>l3),ds[ds$gene_ID==gene,]$RowMEAN <- ds[ds$gene_ID==gene,]$mean_diffsiSam68,
                 ds[ds$gene_ID==gene,]$RowMEAN <- ds[ds$gene_ID==gene,]$mean_diffsiCFIM25))
}
```

This one kinda useless but there are 7 genes with more than 2 features (as different ones where picked up for different siRNA ds) so I picked the 2 with biggest effect (after decided for which siRNA the effect was biggest)
```{r}
a <- ds  %>% group_by(gene_ID) %>% filter(category=='Regulatable_sites') %>% slice_max(RowMEAN)
b <- ds  %>% group_by(gene_ID) %>% filter(category=='Regulatable_sites') %>% slice_min(RowMEAN)

to_remove <- ds[ds$category=='Regulatable_sites',][!(ds[ds$category=='Regulatable_sites',]$unique_featureID %in% rbind(a,b)$unique_featureID),]$unique_featureID

ds <- ds[!(ds$unique_featureID %in% to_remove),]

ds[ds$category=='PRMT_regulated',]$RowMEAN <- rowMeans(ds[ds$category=='PRMT_regulated',10:14],na.rm = T)

#a <- ds[ds$category=='Regulatable_sites',c(1:14,85:89)]
```



Added column called location where inserted if PAS was proximal or distal

```{r}

ds$Location <- 'distal'
for (gene in ds$gene_ID) {
  if (nrow(ds[ds$gene_ID==gene,])>2) {
    ds[ds$gene_ID==gene,]$Location <- NA
  }else{
  
  ifelse ((ds[ds$gene_ID==gene,]$strand=='+') ,
    {if(ds[ds$gene_ID==gene,]$start[1] >ds[ds$gene_ID==gene,]$start[1] ) {
      ds[ds$gene_ID==gene,][2,]$Location <- 'proximal'
    }else{
      ds[ds$gene_ID==gene,][1,]$Location <- 'proximal'
      }},
    {if(ds[ds$gene_ID==gene,]$start[1] >ds[ds$gene_ID==gene,]$start[1] ) {
      ds[ds$gene_ID==gene,][1,]$Location <- 'proximal'
    }else{
      ds[ds$gene_ID==gene,][2,]$Location <- 'proximal'
    }} )}
  
}

table(complete.cases(ds$Location ))


ds <- ds %>% group_by(gene_ID) %>% mutate(Effect= 
                                      ifelse(category!='Control_sites'
                                             ,ifelse((Location=='distal' & RowMEAN>0)
                                               ,'lengthening',
                                               ifelse((Location=='proximal' & RowMEAN<0)
                                               ,'lengthening','shortening'
                                               )
                                               ),
                                               'Control')
                                             )


a <- ds[,c(1:14,85:90)]

```


## let's see if I can add a dummy variable for Location and Shortening/lengthening

```{r}
ds <- ds %>% mutate(Location_dummy = ifelse(Location=='distal',1,0))
ds <- ds %>% mutate(Effect_dummy = ifelse(Effect=='shortening',1,
                                          ifelse(Effect=='lengthening',2,0)))

```

### plot shortening lenghtening


```{r}
library(ggplot2)
barplot(table(ds$category))
barplot(table(ds$Effect),group_by=ds$category,col = rainbow(3))

table(ds$Effect,ds$category)
```



#Hierarchical clustering 

Complete
(or furthest-neighbor): it is the maximal intercluster dissimilarity.
Compute all pairwise dissimilarities between the observations in cluster A and the observations in cluster B, and record the largest of these dissimilarities.

See both!
```{r}
library(stats)
library(readr)
library(dplyr)
library(dendextend)
```


```{r}
#ds <- read_csv('../Outputs/All_categories_df.csv')
rownames(ds) <- ds$unique_featureID

set.seed(1234)
```


first take the complete cases (no NA) of the mean diff columns
Add a column that assigns a color to the 3 categories

### normal

```{r}
ds.1 <- ds[complete.cases(ds[,7:14]),]

ds.1 <-ds.1 %>%  mutate(, color = ifelse(category=='Control_sites','red' ,  ifelse(category=='Regulatable_sites','blue' , "yellow")))
```


IMPORTANT: convert df to matrix otherwise the rownames won't be kept and we need them to backtrace the color in the other matrix

```{r}
ds.1 <- as.matrix(ds.1[,c(7:14,1,87,93)])

rownames(ds.1) <-ds.1[,'unique_featureID']
```

Compute distance (without the columns with categorical data: unique feature, the category and the color assigned)
Then do clustering with hclust method complete should be best
```{r}
distSamples <- dist(ds.1[,-c(9,10,11)])
hc <- hclust(distSamples,method = 'complete')
hc
```

Convert to a dendogram object +
color branches based on the category
```{r}
dend <- as.dendrogram(hc)

dend2 <- color_branches(dend, col=ds.1[labels(dend),'color'])
```

function to remove labels as there are too many and won't be able to read them anyway

```{r}
noLabel <- function(x) {
  if (stats::is.leaf(x)) {
    attr(x, "label") <- NULL }
  return(x)
}

dend2 <- dendrapply(dend2, noLabel)
```


```{r}
plot(dend2 ) ;  rect.hclust(hc,k = 3); legend(x='topleft', legend=c("Control_sites", "Regulatable_sites",'PRMT_regulated'),
       col=c("red", "blue",'yellow'),lty=1, cex=0.8) 

```

```{r}
plot(dend2,horiz = T ); legend(x='topleft', legend=c("Control_sites", "Regulatable_sites",'PRMT_regulated'),
       col=c("red", "blue",'yellow'),lty=1, cex=0.8)
```
### try using dummy variables

```{r}
ds.2 <- ds[complete.cases(ds[,7:14]),]

ds.2 <-ds.2 %>%  mutate(color_categ = ifelse(category=='Control_sites','red' ,  ifelse(category=='Regulatable_sites','blue' , "yellow")))

ds.2 <-ds.2 %>%  mutate(color_effect = ifelse(Effect=='lengthening','red' ,  ifelse(Effect=='shortening','blue' , "yellow")))

ds.2 <- as.matrix(ds.2[,c(7:14,1,87,91,92,93,94)])

rownames(ds.2) <-ds.2[,'unique_featureID']
```

Compute distance (without the columns with categorical data: unique feature, the category and the color assigned)
Then do clustering with hclust method complete should be best
```{r}
distSamples <- dist(ds.2[,-c(9,10,13,14)])
hc <- hclust(distSamples,method = 'complete')
hc
```

```{r}
dend <- as.dendrogram(hc)

dend2 <- color_branches(dend, col=ds.2[labels(dend),'color_categ'])
dend2.2 <- color_branches(dend, col=ds.2[labels(dend),'color_effect'])

```

function to remove labels as there are too many and won't be able to read them anyway

```{r}
noLabel <- function(x) {
  if (stats::is.leaf(x)) {
    attr(x, "label") <- NULL }
  return(x)
}

dend2 <- dendrapply(dend2, noLabel)
dend2.2 <- dendrapply(dend2.2, noLabel)

```


```{r}
plot(dend2.2) ;  rect.hclust(hc,k = 3); legend(x='topleft', legend=c("Lengthening", "Shortening",'Control'),
       col=c("red", "blue",'yellow'),lty=1, cex=0.8) 

```


```{r}
plot(dend2 ) ;  rect.hclust(hc,k = 3); legend(x='topleft', legend=c("Control_sites", "Regulatable_sites",'PRMT_regulated'),
       col=c("red", "blue",'yellow'),lty=1, cex=0.8) 

```

### Do hierarchical clustering separating shortening from lengthening
```{r}
ds.3 <- ds %>% filter(Effect!='shortening')
ds.3 <- ds[complete.cases(ds[,7:14]),]

ds.3 <-ds.3 %>%  mutate(color_categ = ifelse(category=='Control_sites','red' ,  ifelse(category=='Regulatable_sites','blue' , "yellow")))

ds.3 <- as.matrix(ds.3[,c(7:14,1,87,93)])

rownames(ds.3) <-ds.3[,'unique_featureID']
```

```{r}
distSamples <- dist(ds.3[,-c(9,10,11)])
hc <- hclust(distSamples,method = 'complete')
hc
```

```{r}
dend <- as.dendrogram(hc)

dend2 <- color_branches(dend, col=ds.2[labels(dend),'color_categ'])
```

```{r}
noLabel <- function(x) {
  if (stats::is.leaf(x)) {
    attr(x, "label") <- NULL }
  return(x)
}

dend2 <- dendrapply(dend2, noLabel)

```


```{r}
plot(dend2 ) ;  rect.hclust(hc,k = 3); legend(x='topleft', legend=c("Control_sites", "Regulatable_sites",'PRMT_regulated'),
       col=c("red", "blue",'yellow'),lty=1, cex=0.8) 
```



#Complex Heatmaps 

libraries loading

```{r}
library(ComplexHeatmap)
library(RColorBrewer)
library(viridis)
library(circlize)
```

There are quite a lot of NAs (tried and doesnt cluster)
So unfortunately only kept complete cases
cat: mean differences 7:14, 87 category features belong 
```{r}
ds.1 <- ds[complete.cases(ds[,7:14]),c(7:14,87)]
```

```{r}
complete_cases <- ds[complete.cases(ds[,7:14]),7:14]
complete_cases <- as.matrix(complete_cases)
```

## Normal

Tried doing heatmap with values from -1 to 1 but a lot of mis-categorization btween prmt and regulatable 

```{r}
f1 = colorRamp2(seq(min(complete_cases), max(complete_cases), length = 3), c("red", "white", "dark blue"))

#rowAnnotation(foo2 = 18:1, bar2 = anno_barplot(runif(18)) 
Heatmap(complete_cases, name = "Complete cases heatmap",col=f1,row_km  = 3,
    column_title = " Mean difference values",right_annotation =rowAnnotation(category = ds.1$category ))

```
!!!! DO pox dist
+ % of short/leng

## shorteing /lengthening and distal proximal


```{r}
ds.1 <- ds[complete.cases(ds[,7:14]),c(7:14,87,89:92)]

complete_cases <- ds[complete.cases(ds[,7:14]),c(7:14)]
complete_cases <- as.matrix(complete_cases)

f1 = colorRamp2(seq(min(complete_cases), max(complete_cases), length = 3), c("red", "white", "dark blue"))

ds.1 <-ds.1 %>%  mutate( color = ifelse(category=='Control_sites','Pink' ,  ifelse(category=='Regulatable_sites','Light blue' , "yellow")))


#rowAnnotation(foo2 = 18:1, bar2 = anno_barplot(runif(18)) 
Heatmap(complete_cases, name = "Complete cases heatmap",col=f1,row_km  = 3,
    column_title = " Mean difference values",right_annotation =rowAnnotation(category = ds.1$category, effect=ds.1$Effect ))

```

```{r}
complete_cases <- ds[complete.cases(ds[,7:14]),c(7:14,90)]
complete_cases <- as.matrix(complete_cases[,-9])

f1 = colorRamp2(seq(-1,1, length = 3), c("red", "white", "dark blue"))


#rowAnnotation(foo2 = 18:1, bar2 = anno_barplot(runif(18)) 
Heatmap(complete_cases, name = "Complete cases heatmap",col=f1,row_km  = 3,
    column_title = " Mean difference values",right_annotation =rowAnnotation(category = ds.1$category, effect=ds.1$Effect ))

```

