---
title: "hiererchical_clustering"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#hierarchical clustering 

Hierarchical clustering is an alternative clustering approach which does not require a choice of K beforehand.
The bottom-up or agglomerative clustering is the most common type of hierarchical clustering, and refers to the fact that a dendrogram is built starting from the leaves and combining clusters up to the trunk.

We make a horizontal cut across the dendrogram.


We begin by defining some sort of dissimilarity measure between each pair of observations.
The algorithm proceeds iteratively:
• Starting out at the bottom of the dendrogram, each of the n observations is treated as its own cluster.
• The two clusters that are most similar to each other are then fused so that there now are n − 1 clusters.
• Next the two clusters that are most similar to each other are fused again, so that there now are n − 2 clusters.
• The algorithm proceeds in this fashion until all of the observations belong to one single cluster, and the dendrogram is complete.

The concept of dissimilarity between a pair of observations needs to be extended to a pair of groups of observations.
⇒ Concept of linkage: it defines the dissimilarity between two groups of observations.

Average
Mean intercluster dissimilarity.
Compute all pairwise dissimilarities between the observations in cluster A and the observations in cluster B, and record the average of these dissimilarities. Together with the complete linkage, it usually returns more balanced dendrograms.

Complete
(or furthest-neighbor): it is the maximal intercluster dissimilarity.
Compute all pairwise dissimilarities between the observations in cluster A and the observations in cluster B, and record the largest of these dissimilarities.

See both!
```{r}
library(stats)
library(tidyr)
library(readr)
ds <- read_csv('../Outputs/All_categories_df.csv')
#ALL_data_categories_new <- ALL_data_categories
set.seed(1234)
```

```{r}
rownames(ds) <- ds$unique_featureID
```


```{r}
length(unique(ds$gene_ID))
colnames(ds)
All_data <- ds[complete.cases(ds[,7:14]),]


rownames(All_data) <-ds[complete.cases(ds[,7:14]),]$unique_featureID


All_data_short_names <- All_data[,c(7:14)]
rownames(All_data_short_names) <- rownames(All_data)
#ALL_data_categories_numerical <- scale(ALL_data_categories_numerical)

dist_selected_columns <- dist(All_data_short_names)
table()
```

##hierarchical clustering on non cat variables

```{r}
hier_compl <- hclust(dist_selected_columns,method = 'complete')
hier_aver <- hclust(dist_selected_columns,method = 'average')
hier_single <- hclust(dist_selected_columns,method = 'single')
```


```{r}
library(dendextend)
par(mar = c(2,1,0,8)) #make sure the whole plot is on the page
dend <- as.dendrogram(hier_compl) #use dendextend to create dendrogram

dend2 <- color_branches(dend, col=as.factor(All_data[labels(dend),]$category))

plot (dend2, horiz = TRUE) #plot dendrogram
```




```{r}
#hier_compl$merge #illustrates the merging that have been performed
#hier_compl$height #height at merge  (dissimilarity measure)

par(mfrow=c(1,3))
plot(hier_compl, main = 'Complete linkage') # think this is best but let's check
plot(hier_aver, main = 'Average linkage')
plot(hier_single, main = 'Single linkage') #quite bad eheheh

```

```{r}
cut.complete <- cutree(hier_compl,k=3)
cut.average <- cutree(hier_aver,k=3)
```


Let's see after normalization:

```{r}
ds.std <- scale(ALL_data_categories_numerical)
hc.average.std <- hclust(dist(ds.std),method = 'average')
hc.complete.std <- hclust(dist(ds.std),method = 'complete')

plot(hc.average.std)
plot(hc.complete.std)

```
Really shitty clusters!!!!!




Let's evaluate cluster quality

```{r}
library(fpc)
quality.hc <- cluster.stats(dist_selected_columns,cut.complete)
quality.ha <- cluster.stats(dist_selected_columns,cut.average)
```




```{r}
quality_matrix <- matrix(NA,2,3, dimnames = list(c('HC-comp','Hc-aver'),
                                                 c('ASW','PG','CH')))

quality_matrix[1,] <- c(quality.hc$avg.silwidth,quality.hc$pearsongamma,quality.hc$ch)
quality_matrix[2,] <- c(quality.ha$avg.silwidth,quality.ha$pearsongamma,quality.ha$ch)


quality_matrix

```
both good i'd go for complete tho 

#Complex Heatmaps 

libraries loading
```{r}
library(ComplexHeatmap)
library(RColorBrewer)
library(viridis)

```

There are quite a lot of NAs (tried and doesnt cluster)
So unfortunately only kept complete cases
cat: mean differences 7:14, 87 category features belong 
```{r}
ds.1 <- ds[complete.cases(ds[,7:14]),c(7:14,87)]
```


```{r}

pheatmap(ALL_data_categories_numerical[,-c(1,2)], cutree_rows = 3)

```


##
```{r}
library(ComplexHeatmap)


complete_cases <- ds[complete.cases(ds[,7:14]),7:14]
complete_cases <- as.matrix(complete_cases)

Heatmap(complete_cases)

library(circlize)
col_fun = colorRamp2(c(-1, 0, 1), c("green", "white", "red"))
#col_fun(seq(-3, 3))

Heatmap(complete_cases,col = col_fun)




Heatmap(complete_cases, name = "mat", col = rev(rainbow(5)), 
    column_title = "set a color vector for a continuous matrix")
```

```{r}
f1 = colorRamp2(seq(min(complete_cases), max(complete_cases), length = 3), c("blue", "#EEEEEE", "red"))

Heatmap(complete_cases, name = "mat",col=f1,rect_gp = gpar(col = "black", lwd = 0.1),
    column_title = "a matrix with NA values")

```
```{r}
Heatmap(complete_cases, name = "mat",col=f1,show_column_dend = FALSE,
    column_title = "Mean diff")
```


```{r}
f1 = colorRamp2(seq(min(complete_cases), max(complete_cases), length = 3), c("blue", "#EEEEEE", "red"))

#rowAnnotation(foo2 = 18:1, bar2 = anno_barplot(runif(18)) 
Heatmap(complete_cases, name = "mat",col=f1,row_km  = 3,
    column_title = " Mean diff",right_annotation =rowAnnotation(foo2 = ds.1$category ))

```

Let's do with abs value



```{r}
complete_cases_abs <- as.matrix(abs(complete_cases))

f2_all = colorRamp2(c(0, 0.4, 0.8),c("Dark blue", "magenta", "pink"))


Heatmap(complete_cases_abs, name = "mat",col=f2_all,row_km = 3,
    column_title = " Mean diff",right_annotation =rowAnnotation(foo2 = ds.1$category ))

```


```{r}
big_0 <- complete_cases[rowMeans(complete_cases)>0,]

f2_big0 = colorRamp2(c(0, 0.4, 0.8), c("Dark blue", "magenta", "pink"))


Heatmap(big_0, name = "mat",col=f2_big0,row_km = 3,
    column_title = " Mean diff",right_annotation =rowAnnotation(category = ds.1[rowMeans(ds.1[,-9])>0,]$category ))





```


```{r}
less_0 <- complete_cases[rowMeans(complete_cases)<0,]

f2_small0 = colorRamp2(c(0, -0.4, -0.8), c("Dark blue", "magenta", "pink"))


Heatmap(less_0, name = "mat",col=f2_small0,row_km = 3,
    column_title = " Mean diff",right_annotation =rowAnnotation(category = ds.1[rowMeans(ds.1[,-9])<0,]$category ))

```
```{r}

f2_all = colorRamp2(c(0, 0.4, 0.8), c("Dark blue", "magenta", "pink"))


Heatmap(complete_cases_abs, name = "mat",col=f2_all,row_km = 3,
    column_title = " Mean diff",right_annotation =rowAnnotation(category = ds.1$category ))



#col_fun = circlize::colorRamp2(c(0, 10), c("white", "red")),
```

