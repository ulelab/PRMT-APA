---
title: "hiererchical_clustering"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Hierarchical clustering 

Hierarchical clustering is an alternative clustering approach which does not require a choice of K beforehand.
The bottom-up or agglomerative clustering is the most common type of hierarchical clustering, and refers to the fact that a dendrogram is built starting from the leaves and combining clusters up to the trunk.

We make a horizontal cut across the dendrogram.


We begin by defining some sort of dissimilarity measure between each pair of observations.
The algorithm proceeds iteratively:
• Starting out at the bottom of the dendrogram, each of the n observations is treated as its own cluster.
• The two clusters that are most similar to each other are then fused so that there now are n − 1 clusters.
• Next the two clusters that are most similar to each other are fused again, so that there now are n − 2 clusters.
• The algorithm proceeds in this fashion until all of the observations belong to one single cluster, and the dendrogram is complete.

The concept of dissimilarity between a pair of observations needs to be extended to a pair of groups of observations.
⇒ Concept of linkage: it defines the dissimilarity between two groups of observations.

Average
Mean intercluster dissimilarity.
Compute all pairwise dissimilarities between the observations in cluster A and the observations in cluster B, and record the average of these dissimilarities. Together with the complete linkage, it usually returns more balanced dendrograms.

Complete
(or furthest-neighbor): it is the maximal intercluster dissimilarity.
Compute all pairwise dissimilarities between the observations in cluster A and the observations in cluster B, and record the largest of these dissimilarities.

See both!
```{r}
library(stats)
library(tidyr)
library(readr)
library(dplyr)
library(dendextend)
```


```{r}
ds <- read_csv('../Outputs/All_categories_df.csv')
rownames(ds) <- ds$unique_featureID

set.seed(1234)
```


first take the complete cases (no NA) of the mean diff columns
Add a column that assigns a color to the 3 categories

```{r}
ds.1 <- ds[complete.cases(ds[,7:14]),]

ds.1 <- mutate(ds.1, color = ifelse(ds.1$category=='Control_sites','red' ,  ifelse(ds.1$category=='Regulatable_sites','blue' , "yellow")))
```

IMPORTANT: convert df to matrix otherwise the rownames won't be kept and we need them to backtrace the color in the other matrix

```{r}
ds.1 <- as.matrix(ds.1[,c(7:14,1,87,88)])

rownames(ds.1) <-ds.1[,'unique_featureID']
```

Compute distance (without the columns with categorical data: unique feature, the category and the color assigned)
Then do clustering with hclust method complete should be best
```{r}
distSamples <- dist(ds.1[,-c(9,10,11)])
hc <- hclust(distSamples,method = 'complete')
hc
```

Convert to a dendogram object +
color branches based on the category
```{r}
dend <- as.dendrogram(hc)

dend2 <- color_branches(dend, col=ds.1[labels(dend),'color'])
```

function to remove labels as there are too many and won't be able to read them anyway

```{r}
noLabel <- function(x) {
  if (stats::is.leaf(x)) {
    attr(x, "label") <- NULL }
  return(x)
}

dend2 <- dendrapply(dend2, noLabel)
```


```{r}
plot(dend2 ) ;  rect.hclust(hc,k = 3); legend(x='topleft', legend=c("Control_sites", "Regulatable_sites",'PRMT_regulated'),
       col=c("red", "blue",'yellow'),lty=1, cex=0.8) 

```

```{r}
plot(dend2,horiz = T ); legend(x='topleft', legend=c("Control_sites", "Regulatable_sites",'PRMT_regulated'),
       col=c("red", "blue",'yellow'),lty=1, cex=0.8)
```


#Complex Heatmaps 

libraries loading
```{r}
library(ComplexHeatmap)
library(RColorBrewer)
library(viridis)
library(circlize)
```

There are quite a lot of NAs (tried and doesnt cluster)
So unfortunately only kept complete cases
cat: mean differences 7:14, 87 category features belong 
```{r}
ds.1 <- ds[complete.cases(ds[,7:14]),c(7:14,87)]
```

```{r}
complete_cases <- ds[complete.cases(ds[,7:14]),7:14]
complete_cases <- as.matrix(complete_cases)
```

## Normal

Tried doing heatmap with values from -1 to 1 but a lot of mis-categorization btween prmt and regulatable 

```{r}
f1 = colorRamp2(seq(min(complete_cases), max(complete_cases), length = 3), c("red", "white", "dark blue"))

#rowAnnotation(foo2 = 18:1, bar2 = anno_barplot(runif(18)) 
Heatmap(complete_cases, name = "Complete cases heatmap",col=f1,row_km  = 3,
    column_title = " Mean difference values",right_annotation =rowAnnotation(foo2 = ds.1$category ))

```

## Absolute values

Let's do with abs values


```{r}
complete_cases_abs <- as.matrix(abs(complete_cases))

f2_all = colorRamp2(c(0,0.2, 0.4, 0.6,0.8), c('black'," blue", "white",'red' ,"magenta"))


Heatmap(complete_cases_abs, name = "mat",col=f2_all,row_km = 3,
    column_title = " Mean diff",right_annotation =rowAnnotation(foo2 = ds.1$category ))

```

## heatmaps separated between >0 and <0

```{r}
big_0 <- complete_cases[rowMeans(complete_cases[,4:8])>0,]

f2_big0 = colorRamp2(c(0,0.2, 0.4, 0.6,0.8), c('black'," blue", "white",'red' ,"magenta"))


Heatmap(big_0, name = "mat",col=f2_big0,row_km = 3,
    column_title = " Mean diff",right_annotation =rowAnnotation(category = ds.1[rowMeans(ds.1[,4:8])>0,]$category ))





```


```{r}
less_0 <- complete_cases[rowMeans(complete_cases[,4:8])<0,]

f2_small0 = colorRamp2(c(0,-0.2, -0.4, -0.6,-0.8), c('black'," blue", "white",'red' ,"magenta"))


Heatmap(less_0, name = "mat",col=f2_small0,row_km = 3,
    column_title = " Mean diff",right_annotation =rowAnnotation(category = ds.1[rowMeans(complete_cases[,4:8])<0,]$category ))

```






