---
title: "GO_analysis"
output: html_document
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(topGO)
```

<https://bioconductor.org/packages/devel/bioc/vignettes/topGO/inst/doc/topGO.pdf>
https://advaitabio.com/faq-items/understanding-gene-ontology/

# 1 Data preparation



```{r}
df <- read.csv('../Outputs/All_categories_DP_LS.csv')
gene_universe_df <- read.csv('../Outputs/Unfiltered_Formatted_All_Data_Sets_Final.csv')
```

```{r}
PRMT_genes <- unique(df[df$category=='PRMT_regulated',]$gene_ID) # interesting genes
gene_universe <- unique(gene_universe_df$gene_ID) #gene universe 
Ctrl_genes <- unique(df[df$category=='Control_sites',]$gene_ID) # interesting genes
Regulatable_genes <- unique(df[df$category=='Regulatable_sites',]$gene_ID) # interesting genes
#Control_sites"     "Regulatable_sites" "PRMT_regulate
```

Only symbol

```{r}
gene_universe_symbol <- unlist(strsplit(gene_universe,'_'))[seq(1,length(gene_universe)*2,2)]
```

#### Gene lists

```{r}
ds <-  data.frame(matrix(nrow = 5177, ncol =4))
colnames(ds) <- c('_BACKGROUND','PRMT_reg','Regulatable_sites','Control_sites')
ds$'_BACKGROUND' <- gene_universe_symbol
ds$PRMT_reg <- append(PRMT_genes, rep(NA,5177-length(PRMT_genes)))
ds$Regulatable_sites <- append(Regulatable_genes, rep(NA,5177-length(Regulatable_genes)))
ds$Control_sites <- append(Ctrl_genes, rep(NA,5177-length(Ctrl_genes)))
#table(is.na(ds$'_BACKGROUND'))
library(writexl)
write_xlsx(ds,'../GO_analysis/GO_list.xlsx')

```





# Metscape analysis





data


```{r}
library(readxl)
```

```{r}
#CTRL_GO_MCODE <- read_csv('../GO_analysis/CTRL_GO_MCODE.csv')
#ML_GO_MCODE <- read_csv('../GO_analysis/HeatmapSelectedGOTop100.csv')
#PRMT_GO_MCODE <- read_csv('../GO_analysis/PRMT_GO_MCODE.csv')
#REG_GO_MCODE <- read_csv('../GO_analysis/REG_GO_MCODE.csv')
```

```{r}
library(tidyverse)
library(ggplot2)
library(dplyr)
library(Rfast)
```

##multi list 


```{r}
ML_GO_MCODE <- read_csv('../GO_analysis/_FINAL_GO.csv')
```


```{r}
library(circlize)
library(ComplexHeatmap)

a <- ML_GO_MCODE[order(ML_GO_MCODE$Enrichment,decreasing = T),][1:50,]

b <- as.matrix(a[,4:6])
f1 <- colorRamp2(seq(min(a$LogP),-2, length = 3), c("Dark blue", "Magenta", "white"))

hm <- Heatmap(b,col =  f1, border = TRUE, name = "LogP")+rowAnnotation(foo=anno_text( paste(a$GO, a$Description) , gp = gpar(fontsize = 9))) 

draw(hm,column_title="Heatmap top50 enrichement",
   column_title_gp=grid::gpar(fontsize=16))
```

###single categories
```{r}
Reg <- ML_GO_MCODE %>% filter(ML_GO_MCODE$'_MEMBER_Regulatable_sites' == 1)
PRMT <- ML_GO_MCODE %>% filter(ML_GO_MCODE$'_MEMBER_PRMT_reg' == 1)
CTRL <- ML_GO_MCODE %>% filter(ML_GO_MCODE$'_MEMBER_Control_sites' == 1)
```

```{r}
Reg <- Reg[order(Reg$Enrichment,decreasing = T),][1:20,] %>% filter(LogP< -2)
plot_reg <- ggplot(Reg, aes(x=- LogP, y=reorder(paste(GO,Description),-LogP),colour=-LogP,size=Enrichment) )+scale_color_gradient2(high = "#DC143C")+
  xlab("-log(P)") +
ylab("GO")+
    geom_point()+theme_bw()+labs(colour="-log(P)")+ggtitle('GO results Regulatable')
plot_reg
```
```{r}
PRMT <- PRMT[order(PRMT$Enrichment,decreasing = T),][1:20,]%>% filter(LogP< -2)
plot_prmt <- ggplot(PRMT, aes(x=- LogP, y=reorder(paste(GO,Description),-LogP),colour=-LogP,size=Enrichment) )+scale_color_gradient2(high = "#DC143C")+
  xlab("-log(P)") +
ylab("GO")+
    geom_point()+theme_bw()+labs(colour="-log(P)")+ggtitle('GO results PRMT')
plot_prmt
```

```{r}
CTRL <- CTRL[order(CTRL$Enrichment,decreasing = T),][1:20,]%>% filter(LogP< -2)
plot_CTRL <- ggplot(CTRL, aes(x=- LogP, y=reorder(paste(GO,Description),-LogP),colour=-LogP,size=Enrichment) )+scale_color_gradient2(high = "#DC143C")+
  xlab("-log(P)") +
ylab("GO")+
    geom_point()+theme_bw()+labs(colour="-log(P)")+ggtitle('GO results Control sites')
plot_CTRL
```



```{r}
ds <- read_csv('../Outputs/All_categories_DP_LS.csv')
list_PRMT_FGFRL1 <- strsplit(ML_GO_MCODE[ML_GO_MCODE$GO=='R-HSA-5658623',]$Hits,'\\|')
vector_PRMT_FGFRL1 <- unlist(list_PRMT_FGFRL1)

Effect_double <- ds[ds$gene_ID %in% vector_PRMT_FGFRL1,]$Effect
names(Effect_double) <- ds[ds$gene_ID %in% vector_PRMT_FGFRL1,]$gene_ID
table(Effect_double)/2


list_reg_FGFR2 <- strsplit(ML_GO_MCODE[ML_GO_MCODE$GO=='R-HSA-5654738',]$Hits,'\\|')
vector_reg_FGFR2 <- unlist(list_reg_FGFR2)
Effect_double_reg <- ds[ds$gene_ID %in% vector_reg_FGFR2,]$Effect
names(Effect_double_reg) <- ds[ds$gene_ID %in% vector_reg_FGFR2,]$gene_ID
table(Effect_double_reg)/2

table(ds$category,ds$Effect)
```




##PRMT

```{r}
PRMT_GO_MCODE_ord <- PRMT_GO_MCODE[order(PRMT_GO_MCODE$LogP),][1:20,]
#GO_results_ordered <- GO_results_ordered[1:10,]
plot_prmt <- ggplot(PRMT_GO_MCODE_ord, aes(x=- LogP, y=reorder(paste(GO,Description),-LogP),colour=-LogP,size=`#GeneInGO`) )+scale_color_gradient2(high = "#DC143C")+
  xlab("-log(P)") +
ylab("GO")+
    geom_point()+theme_bw()+labs(colour="-log(P)")+ggtitle('GO results PRMT-reg')

#ggsave(plot_prmt,filename="../Pictures/GO results PRMT reg",device=png,width = 12,height = 7)

plot_prmt
```


##Regulatable


```{r}
REG_GO_MCODE_ord <- REG_GO_MCODE[order(REG_GO_MCODE$LogP),][1:20,]
plot_reg <- ggplot(REG_GO_MCODE_ord, aes(x=- LogP, y=reorder(paste(GO,Description),-LogP),colour=-LogP,size=`#GeneInGO`) )+scale_color_gradient2(high = "#DC143C")+
  xlab("-log(P)") +
ylab("GO")+
    geom_point()+theme_bw()+labs(colour="-log(P)")+ggtitle('GO results Regulatable')
plot_reg
```

##control

```{r}
CTRL_GO_MCODE_ord <- CTRL_GO_MCODE[order(CTRL_GO_MCODE$LogP),][1:20,]
plot_ctrl <- ggplot(CTRL_GO_MCODE_ord, aes(x=- LogP, y=reorder(paste(GO,Description),-LogP),colour=-LogP,size=`#GeneInGO`) )+scale_color_gradient2(high = "#DC143C")+
  xlab("-log(P)") +
ylab("GO")+
    geom_point()+theme_bw()+labs(colour="-log(P)")+ggtitle('GO results Regulatable')
plot_ctrl
```

#TopGO analysis

input of top go is a named factor vector.
if 0 gene is not interesting but part of universe, id 1 gene is interesting and part of universe

```{r}
geneList_PRMT <- factor(as.integer(gene_universe_symbol %in% PRMT_genes ))
geneList_Reg <- factor(as.integer(gene_universe_symbol %in% Regulatable_genes ))
geneList_Ctrl <- factor(as.integer(gene_universe_symbol %in% Ctrl_genes ))

names(geneList_PRMT) <- gene_universe_symbol
names(geneList_Reg) <- gene_universe_symbol
names(geneList_Ctrl) <- gene_universe_symbol
```

```{r}
table(names(geneList_PRMT[geneList_PRMT==1]) %in% PRMT_genes) #Check that everything is correct up to now
```

### GO DATA

We further describe the arguments of the initialize function (new) used to construct an instance of this data container object.

**ontology**: character string specifying the ontology of interest: used BP0biological process (others: MF,CC)

**description**: character string containing a short description of the study [optional].

**allGenes**: named vector of type numeric or **factor (0,1:interesting genes)**.
The names attribute contains the genes identifiers.
The genes listed in this object are the gene universe.

**(geneSelectionFun**: function to specify which genes are interesting based on the gene scores. It should be present if the allGenes object is of type numeric.)

( nodeSize: an integer larger or equal to 1. This parameter is used to prune the GO hierarchy from the terms which have less than nodeSize annotated genes (after the true path rule is applied).)

[**annotationFun**]{.ul}: function which maps genes identifers to GO terms.
There are a couple of annotation function included in the package trying to address the user's needs.
The annotation functions take three arguments.
One of those arguments is specifying where the mappings can be found, and needs to be provided by the user.
Here we give a short description of each:

can be: [**annotationFun=**]{.ul}annFUN.db, specify other param OR [**annotationFun=**]{.ul}annFUN.db(specify param)

annFUN.db this function is intended to be used as long as the chip used by the user has an annotation package available in Bioconductor.
**annFUN.org** this function is using the mappings from the "org.XX.XX" annotation packages.
Cur- rently, the function supports the following gene identi􏰂ers: Entrez, GenBank, Alias, Ensembl, Gene Symbol, GeneName and UniGene.
annFUN.gene2GO this function is used when the annotations are provided as a gene-to-GOs mapping.
annFUN.GO2gene this function is used when the annotations are provided as a GO-to-genes mapping.
annFUN.file this function will read the annotationsof the type gene2GO or GO2genes from a text 􏰂le.
...: list of arguments to be passed to the annotationFun

**mapping:** character string specifieng the name of the Bioconductor package containing the gene mappings for a specific organism.
For example: mapping = "org.Hs.eg.db".

**ID**\
character string specifing the gene identifier to use.
Currently only the following identifiers can be used: c("entrez", "genbank", "alias", "ensembl", "symbol", "genename", "unigene")

```{r}
 GOdata <- new("topGOdata", ontology = "BP", allGenes = geneList_PRMT,annotationFun = annFUN.org, ID="symbol",mapping= 'org.Hs.eg.db')
```


One important point to notice is that not all the genes that are provided by geneList, the initial gene universe, can be annotated to the GO. (4794 unverse, 593 signific genes)
This can be seen by comparing the number of all available genes, the genes present in geneList, with the number of feasible genes.
We are therefore forced at this point to restrict the gene universe to the set of feasible genes for the rest of the analysis.
The summary on the GO graph shows the number of GO terms and the relations between them of the speci􏰂ed GO ontology.
This graph contains only GO terms which have at least one gene annotated to them!

#### Useful fx to retrieve data info
```{r}
head(genes(GOdata))
head(sigGenes(GOdata))
```


```{r}
head(usedGO(GOdata))
```

Select genes: if not parsed does all terms
```{r}
selected_terms <- head(usedGO(GOdata))
```

retrieve the number of annotated genes
```{r}
number_annot_genes <- countGenesInTerm(GOdata, selected_terms) 
number_annot_genes
```

```{r}
annotated_genes <- genesInTerm(GOdata, selected_terms) # get the annotations
annotated_genes
```
get some stats

```{r}
termStat(GOdata, selected_terms)
```

## 2 Running the enrichment tests


topGO package was designed to work with various test statistics and various algorithms which take the GO dependencies into account. At the base of this design stands a S4 class mechanism which facilitates defining and executing a (new) group test. Three types of enrichment tests can be distinguish if we look at the data used by the each test.
􏰅 Tests based on gene counts. This is the most popular family of tests, given that it only requires the presence of a list of interesting genes and nothing more. Tests like Fisher's exact test, Hypegeometric test and binomial test belong to this family. Draghici et al. (2006)
􏰅 Tests based on gene scores or gene ranks. It includes Kolmogorov-Smirnov like tests (also known as GSEA), Gentleman's Category, t-test, etc. Ackermann and Strimmer (2009)
􏰅 Tests based on gene expression. Tests like Goeman's globaltest or GlobalAncova separates from the others since they work directly on the expression matrix. Goeman and Bühlmann (2007)

fx to see what tests/algo you can do: whichTests() and whichAlgorithms()


decided to use fihser and weight 01:

fisher:  determine if there are nonrandom associations between two categorical variables
weight01: mix between weight and elim made to avoid problem:
When a gene is annotated with a term, all inferences that can be inferred from the structure of the GO must also hold true. This property is known as the “True Path Rule.” But, because of this, if the GO analysis is done independently, for each term, each gene will be counted multiple times, once for every term from the lowest term it is annotated with, all the way up to the root. This has two consequences. First, it injects a great deal of redundancy in the process and second, it tends to report as significant lots of general terms which are really not very informative with respect to the phenotype studies.


Two methods by Alexa et al (2006). Elim starts at the lowest level of GO, with the most specific terms and calculates their enrichment p-value. If that is not significant, the approach moves up in the hierarchy and calculates the p-value as usual. If “induction of apoptosis by extracellular signals” is not significant, all DE genes associated with it will also be counted for its parent, “induction of apoptosis”, as if the two terms were independent. However, if the more specific term is indeed significant, elim will eliminate all genes associated with it from all its ancestors, thus eliminating the redundancy and giving a chance to the more specific terms to be reported as significant.

Second method is called weight. The idea behind this approach is that if many very specific terms are significant, and there is a term slightly more general that would encompass all those terms, it may be useful to identify this more general term

```{r}
resultFis <- runTest(GOdata, algorithm = "weight01", statistic = "fisher")
#resultClassic <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
#resultElim <- runTest(GOdata, algorithm = "elim", statistic = "fisher")

```
```{r}
resultFis
```


```{r}
showSigOfNodes(GOdata, score(resultFis), useInfo = "none", sigForAll=FALSE, firstSigNodes=2,.NO.CHAR=50)
```



####multiple comparisons adjustment yes/no?

The p-values return by the getSigGroups function are row p-values. There is no multiple testing correction applied to them, unless the test statistic directly incorporate such a correction. Of course, the researcher can perform an adjustment of the p-values if he considers it is important for the analysis. The reason for not automatically correcting for multiple testing are:
􏰅 In many cases the row p-values return by an enrichment analysis are not that extreme. A FDR/FWER adjustment procedure can in this case produce very conservative p-values and declare no, or very few, terms as significant. This is not necessary a bad thing, but it can happen that there are interesting GO terms which didn't make it over the cutoff but they are omitted and thus valuable information lost. In this case the researcher might be interested in the ranking of the GO terms even though no top term is significant at a specify FDR level.
􏰅 One should keep in mind that an enrichment analysis consist of many steps and there are many assumptions done before applying, for example, Fisher's exact test on a set of GO terms. Performing a multiple testing procedure accounting only on the number of GO terms is far from being enough to control the error rate.
􏰅 For the methods that account for the GO topology like elim and weight, the problem of multiple testing is even more complicated. Here one computes the p-value of a GO term conditioned on the neighbouring terms. The tests are therefore not independent and the multiple testing theory does not directly apply. We like to interpret the p-values returned by these methods as corrected or not a􏰁ected by multiple testing.


-> talk to charlotte 

-> metascape used the BH correction so used that as well for a start

```{r}
 pvalFis <- score(resultFis)
hist(pvalFis)
#p.adjust(sort(pvalFis,decreasing = T), 'BH')#nothing is significant now 
```






```{r}
set.seed(1234)
library(multtest)
allRes <- GenTable(GOdata, weight = resultFis, topNodes = 50)
#allRes$weight
allRes$weight <- as.numeric(allRes$weight)
allRes$log_w <- log10(allRes$weight) 
allRes$adj <- p.adjust(allRes$weight,'BH')
allRes$adj_log <- log10(allRes$adj) 
```

```{r}
library(ggplot2)
ggplot(allRes[1:20,], aes(x=-log_w, y=reorder(paste(GO.ID,Term),-log_w),color=log_w,size=Significant) )+scale_color_gradient(low = "magenta",high='blue')+
  xlab('') +
ylab("GO")+
    geom_point()+theme_bw()+labs(colour='weight')+ggtitle('GO results PRMT-reg')


```
```{r}
ggplot(allRes[1:20,], aes(x=-adj_log, y=reorder(paste(GO.ID,Term),-adj_log),color=-adj_log,size=Significant) )+scale_color_gradient(low = "magenta",high='blue')+
  xlab('') +
ylab("GO")+
    geom_point()+theme_bw()+labs(colour='weight')+ggtitle('GO results PRMT-reg')

```




#clusterProfiler
https://yulab-smu.top/biomedical-knowledge-mining-book/clusterprofiler-kegg.html
```{r}
library(gProfileR)
library(clusterProfiler)
```

```{r}
df <- read.csv('../Outputs/All_categories_DP_LS.csv')
gene_universe_df <- read.csv('../Outputs/Unfiltered_Formatted_All_Data_Sets_Final.csv')
```

```{r}
PRMT_genes <- unique(df[df$category=='PRMT_regulated',]$gene_ID) # interesting genes
gene_universe <- unique(gene_universe_df$gene_ID) #gene universe 
Ctrl_genes <- unique(df[df$category=='Control_sites',]$gene_ID) # interesting genes
Regulatable_genes <- unique(df[df$category=='Regulatable_sites',]$gene_ID) # interesting genes

gene_universe_symbol <- unlist(strsplit(gene_universe,'_'))[seq(1,length(gene_universe)*2,2)]

```

```{r}
geneList_PRMT <- factor(as.integer(gene_universe_symbol %in% PRMT_genes ))
geneList_Reg <- factor(as.integer(gene_universe_symbol %in% Regulatable_genes ))
geneList_Ctrl <- factor(as.integer(gene_universe_symbol %in% Ctrl_genes ))

names(geneList_PRMT) <- gene_universe_symbol
names(geneList_Reg) <- gene_universe_symbol
names(geneList_Ctrl) <- gene_universe_symbol
```
### GO
```{r}
ego <- enrichGO(gene          = PRMT_genes,
                #universe      = gene_universe_symbol,
                OrgDb         = 'org.Hs.eg.db',
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                keyType = "SYMBOL",
        readable      = TRUE)
head(ego)
```


```{r}
library(enrichplot)
barplot(ego, showCategory=20) 
```
```{r}
mutate(ego, qscore = -log(p.adjust, base=10)) %>% 
    barplot(x="qscore")
```

```{r}
dotplot(ego,x='Count', showCategory=30) + ggtitle("dotplot for ORA")
```
###Kegg
```{r}
library(org.Hs.eg.db)

library(annotate)

getUniqAnnItem()


kk <- enrichKEGG(gene         = PRMT_genes,
                 organism     = 'hsa',
                 universe      = gene_universe_symbol,
                 keyType = "kegg",
                 pvalueCutoff = 0.05)
head(kk)

write.csv(PRMT_genes,'~/Desktop/prmt.csv')

```

